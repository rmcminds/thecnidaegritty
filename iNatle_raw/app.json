[{"name":"app.R","content":"library(shiny)\nlibrary(htmltools)\nlibrary(bslib)\nlibrary(jsonlite)\nlibrary(i18n)\nlibrary(stringi)\n\n# Create list of language options\nsimplei18n <- grep('-', all_locales, invert = TRUE)\nsimplei18n <- sapply(simplei18n, \\(x) locale_names[x,2][[1]][all_locales[[x]]])\nlocales_list <- setNames(names(simplei18n), simplei18n)\n\n# Create UI. Mostly a frame that is filled in by the server.\nui <- fluidPage(\n  \n  theme = bs_theme(version = 4),\n\n  # Link to external CSS file\n  tags$head(\n    includeCSS(\"www/styles.css\")\n  ),\n\n  div(id = 'mycontainer', \n    div(\n      class = 'setup',\n      uiOutput('setup_ui'),\n      uiOutput('notices_ui')\n    ),\n    \n    div(\n      class = \"guesses\",\n      uiOutput('game_ui')\n    )\n  ),\n\n  # Link to external JS file\n  includeScript(\"www/custom.js\")\n)\n\n# Get iNat tax info from an arbitrary string, genus, or ID number\nget_tax <- function(taxon_name = NULL, genus = FALSE, taxon_id = NULL, locale = NULL) {\n  \n  params <- list()\n  if(!is.null(taxon_name)) params$q <- taxon_name\n  if(genus) params$rank <- \"genus\"\n  if(!is.null(taxon_id)) params$taxon_id <- taxon_id\n  if(!is.null(locale)) params$locale <- locale\n  \n  query <- paste0(paste0(names(params), \"=\", sapply(as.character(params), URLencode), collapse = \"&\"), \n                  \"&order=desc&order_by=observations_count&per_page=1\")\n  \n  full_url <- paste0(\"https://api.inaturalist.org/v1/taxa?\", query)\n  response <- readLines(url(full_url), warn = FALSE)\n  json_response <- paste(response, collapse = \"\")\n  obj <- fromJSON(json_response, simplifyVector = FALSE)\n\n  res <- obj$results[[1]]\n  \n  return(res)\n  \n}\n\n# Get species counts or a specific observation\nget_observations <- function(taxon_id   = NULL, \n                             year       = NULL, \n                             month      = NULL, \n                             day        = NULL, \n                             bounds     = NULL, \n                             user_login = NULL, \n                             locale     = NULL,\n                             created_d2 = NULL,\n                             counts     = FALSE,\n                             page       = 1,\n                             per_page   = 1,\n                             id         = NULL) {\n  \n    # Base URL\n    base_url <- \"https://api.inaturalist.org/v1/observations/\"\n    if(counts) {\n      base_url <- paste0(base_url, \"species_counts/?\")\n    } else {\n      base_url <- paste0(base_url, \"?\")\n    }\n\n    # Construct the query parameters\n    params <- list(verifiable = 'true',\n                   photos     = 'true',\n                   hrank      = 'genus',\n                   locale     = locale,\n                   created_d2 = created_d2,\n                   per_page   = per_page,\n                   page       = page)\n\n    if(!is.null(taxon_id)) params$taxon_id <- taxon_id\n    if(!is.null(year)) params$year <- year\n    if(!is.null(month)) {\n      month <- as.numeric(month)\n      if(month < 1 || month > 12) stop(\"Month must be between 1 and 12.\")\n      params$month <- month\n    }\n    if(!is.null(day)) {\n      day <- as.numeric(day)\n      if(day < 1 || day > 31) stop(\"Day must be between 1 and 31.\")\n      params$day <- day\n    }\n    if(!is.null(bounds)) {\n      if(length(bounds) != 4) stop(\"Bounds must have 4 coordinates.\")\n      bounds <- unname(bounds)\n      params$swlat <- bounds[1]\n      params$swlng <- bounds[2]\n      params$nelat <- bounds[3]\n      params$nelng <- bounds[4]\n    }\n    if(!is.null(user_login)) params$user_login <- user_login\n    if(!is.null(id)) params$id <- id\n\n    # Create URL with query parameters\n    query <- paste0(names(params), \"=\", sapply(as.character(params), URLencode), collapse = \"&\")\n    full_url <- paste0(base_url, query)\n\n    response <- readLines(url(full_url), warn = FALSE)\n    json_response <- paste(response, collapse = \"\")\n    obj <- fromJSON(json_response, simplifyVector=FALSE)\n\n    return(obj)\n  \n}\n\n# Choose the word of the day\nchoose_taxon <- function(obj, maxchar = 100) {\n\n  sp_counts <- sapply(obj$results, \\(x) x$count)\n  species <- sapply(obj$results, \\(x) x$taxon$name)\n  genera <- sapply(strsplit(species, ' '), \\(x) x[[1]])\n  \n  gen_counts <- sapply(unique(genera), \\(x) sum(sp_counts[genera == x]))\n  gen_counts <- gen_counts[sapply(strsplit(unique(genera),''), length) <= maxchar]\n  \n  target_genus <- sample(names(gen_counts), 1)\n\n  return(target_genus)\n  \n}\n\n# Find all 5-letter substrings with up to one mismatch between target and hint, and censor them so the hint doesn't make it too easy\ncensor_hints <- function(target, hint) {\n  \n  target_length <- nchar(target)\n  target_segments <- sapply(1:(target_length-4), \\(i) substr(stringi::stri_trans_general(tolower(target), \"Latin-ASCII\"), i, i+4))\n  \n  pattern <- paste(sapply(target_segments, \\(x) sapply(1:5, \\(y) paste0(substr(x, 1, y-1), '.?', substr(x, y+1, nchar(x))))), collapse='|')\n  \n  # Allow overlapping matches (adding 'PCRE' pattern...)\n  pattern <- paste0('(?=(', pattern, '))')\n  \n  # Find matches in the original string, using normalized version\n  matches <- gregexpr(pattern, stringi::stri_trans_general(tolower(hint), \"Latin-ASCII\"), perl = TRUE)\n  \n  # Get positions of matches\n  match_positions <- unlist(matches)\n  \n  # Initialize modified string\n  modified_string <- hint\n  attr(modified_string, 'censored') <- FALSE\n  \n  # Replace matches in the original string at the identified positions\n  if(length(match_positions) > 0 && match_positions[1] != -1) {\n    for(i in 1:length(match_positions)) {\n      # Replace the matching characters with dashes\n      modified_string <- paste0(\n        substr(modified_string, 1, match_positions[[i]] - 1), \n        paste(rep('-', attr(matches[[1]], 'capture.length')[[i]]), collapse = ''), \n        substr(modified_string, match_positions[[i]] + attr(matches[[1]], 'capture.length')[[i]], nchar(modified_string))\n      )\n    }\n    \n    attr(modified_string, 'censored') <- TRUE\n\n  }\n  \n  return(modified_string)\n  \n}\n\n# Do all the real work\nserver <- function(input, output, session) {\n  \n  # Reactive Values Initialization\n  r <- reactiveValues(is_random    = TRUE,\n                      per_page     = 200,\n                      rarity       = 1,\n                      maxchar      = 10,\n                      placename    = 'Oregon',\n                      input_taxon  = 'Plantae',\n                      user_login   = '',\n                      locale       = 'en',\n                      ready        = FALSE,\n                      started      = FALSE,\n                      target_word  = character(0),\n                      ref_obs      = NULL,\n                      tax_info     = NULL,\n                      pretext      = NULL,\n                      all_guesses  = list(),\n                      notices      = '',\n                      finished     = FALSE,\n                      showimage    = FALSE,\n                      showcommon   = FALSE,\n                      current_guess_letters = character(0))\n  \n  observe({\n    \n    # If a link was used that has parameters, load them\n    query <- parseQueryString(session$clientData$url_search)\n    isolate({\n      if('locale' %in% names(query)) r$locale <- query[['locale']]\n      if('obs_id' %in% names(query)) updateTextInput(session, 'obs_id', value = query[['obs_id']])\n      if('placename' %in% names(query)) r$placename <- query[['placename']]\n      if('input_taxon' %in% names(query)) r$input_taxon <- query[['input_taxon']]\n      if('user_login' %in% names(query)) r$user_login <- query[['user_login']]\n    })\n    reset_game()\n  \n  })\n\n  try_place <- function(placename, taxid) {\n    \n    if(placename == '') {\n      \n      bounds <- NULL\n      place_display_name <- NULL\n      \n    } else {\n  \n      base_url <- \"https://nominatim.openstreetmap.org/search\"\n      query <- paste0(\"?q=\", URLencode(placename), \"&format=json\")\n      full_url <- paste0(base_url, query)\n  \n      response <- readLines(url(full_url), warn = FALSE)\n      json_response <- paste(response, collapse = \"\")\n      obj <- fromJSON(json_response, simplifyVector=FALSE)[[1]]\n  \n      place_display_name <- obj$display_name\n      bounds <- as.numeric(obj$boundingbox)[c(1,3,2,4)]\n    \n    }\n    \n    # This should help stabilize the queries throughout the day\n    created_d2 <- format(Sys.Date() - 1, \"%Y-%m-%d\")\n\n    if(any(is.na(bounds))) {\n\n      r$notices <- 'Place name not found'\n      reset_game()\n\n    } else {\n      \n      user_login <- if(input$user_login == '') NULL else input$user_login\n\n      tryCatch({\n        get_random_obs(\n          taxid      = taxid,\n          user_login = user_login,\n          bounds     = bounds,\n          year       = format(Sys.Date() - 1, \"%Y\"),\n          month      = format(Sys.Date() - 1, \"%m\"),\n          day        = format(Sys.Date() - 1, \"%d\"),\n          created_d2 = created_d2\n        )\n        r$pretext <- paste0('I was observed yesterday', paste0(' in ', place_display_name)[!is.null(place_display_name)], '!')\n      }, error = function(e1) {\n        print(e1)\n        tryCatch({\n          get_random_obs(\n            taxid      = taxid,\n            user_login = user_login,\n            bounds     = bounds,\n            month      = format(Sys.Date(), \"%m\"),\n            day        = format(Sys.Date(), \"%d\"),\n            created_d2 = created_d2\n          )\n          r$pretext <- paste0('I was observed on this date', paste0(' in ', place_display_name)[!is.null(place_display_name)], '!')\n        }, error = function(e2) {\n          print(e2)\n          tryCatch({\n            get_random_obs(\n              taxid      = taxid,\n              user_login = user_login,\n              bounds     = bounds,\n              month      = format(Sys.Date(), \"%m\"),\n              created_d2 = created_d2\n            )\n            r$pretext <- paste0('I was observed in this month of the year', paste0(' in ', place_display_name)[!is.null(place_display_name)], '!')\n          }, error = function(e3) {\n            print(e3)\n            tryCatch({\n              get_random_obs(\n                taxid      = taxid,\n                user_login = user_login,\n                bounds     = bounds,\n                created_d2 = created_d2\n              )\n              r$pretext <- paste0('I was observed at some time in the past', paste0(' in ', place_display_name)[!is.null(place_display_name)], '!')\n            }, error = function(e4) {\n              print(e4)\n              r$notices <- 'No observations match all inputs; try again'\n              reset_game()\n            })\n          })\n        })\n      })\n\n    }\n  }\n  \n  get_specific_obs <- function(obs_id = NULL) {\n    \n    r$pretext <- '' # maybe should add info about time location drawn from observation instead of user inputs\n    \n    # Today's observation\n    r$ref_obs <- tryCatch({\n      get_observations(id = obs_id, locale = r$locale)\n    }, error = \\(e) NA)\n    \n    if(!anyNA(r$ref_obs)) {\n      \n      # Today's target genus\n      r$target_word <- tolower(strsplit(r$ref_obs$results[[1]]$taxon$name, ' ')[[1]][[1]])\n      \n      # Taxonomy info for today's target genus\n      r$tax_info <- get_tax(r$target_word, TRUE, locale = r$locale)\n      \n    }\n\n  }\n  \n  get_random_obs <- function(taxid = NULL, user_login = NULL, bounds = NULL, year = NULL, month = NULL, day = NULL, created_d2 = NULL) {\n    \n    # Observation counts fitting search criteria\n    sc <- get_observations(\n      taxon_id   = taxid,\n      user_login = user_login,\n      bounds     = bounds,\n      year       = year,\n      month      = month,\n      day        = day,\n      created_d2 = created_d2,\n      locale     = r$locale,\n      counts     = TRUE,\n      page       = r$rarity,\n      per_page   = r$per_page\n    )\n    \n    if(sc$total_results == 0) stop(simpleError('No observations matching criteria'))\n\n    # If rarity is just the page number, then must be limited to number of pages\n    max_rarity <- ceiling(sc$total_results / r$per_page)\n    if(r$rarity > max_rarity) { \n      \n      r$rarity <- max_rarity\n      r$notices <- 'Rarity scaled down due to low number of species that match query'\n      \n      # Get the last page, since first attempt would have returned nothing\n      sc <- get_observations(\n        taxon_id   = taxid,\n        user_login = user_login,\n        bounds     = bounds,\n        year       = year,\n        month      = month,\n        day        = day,\n        created_d2 = created_d2,\n        locale     = r$locale,\n        counts     = TRUE,\n        page       = r$rarity,\n        per_page   = r$per_page\n      )\n      \n    }\n    \n    # Today's target genus\n    r$target_word <- tolower(choose_taxon(sc, r$maxchar))\n    \n    # Taxonomy info for today's target genus\n    r$tax_info <- get_tax(r$target_word, TRUE, locale = r$locale)\n    \n    # Today's observation\n    r$ref_obs <- get_observations(taxon_id   = r$tax_info$id,\n                                  user_login = user_login,\n                                  bounds     = bounds,\n                                  year       = year,\n                                  month      = month,\n                                  day        = day,\n                                  created_d2 = created_d2,\n                                  locale     = r$locale)\n\n  }\n\n  assemble_game <- function() {\n    \n    # Taxonomy info for today's observation\n    obstax <- get_tax(taxon_id = r$ref_obs$results[[1]]$taxon$id, locale = r$locale)\n    \n    # Explanation of today's observation\n    output$pretext <- renderText({ paste0('<p style=\"margin-bottom: 10px\">', r$pretext, '<\/p>') })\n\n    # HTML for image and link\n    output$iurl <- renderText({\n      c('<a href=\"', r$ref_obs$results[[1]]$uri, '\" target=\"_blank\"><img src=\"', paste0(dirname(r$ref_obs$results[[1]]$photos[[1]]$url), '/', sub('square', 'medium', basename(r$ref_obs$results[[1]]$photos[[1]]$url))), '\" style=\"max-width: 100%;\"><\/a>')\n    })\n\n    # Contsruct common genus name hint\n    if('preferred_common_name' %in% names(r$tax_info)) {\n      \n      intro_genus <- paste0(\"The common name for my genus in <b>\", names(locales_list)[locales_list == r$locale], \"<\/b> is <em>\")\n      common_genus <- censor_hints(r$target_word, r$tax_info$preferred_common_name)\n      \n    } else if('english_common_name' %in% names(r$tax_info)) {\n      \n      intro_genus <- paste0(\"The common name for my genus isn't available on iNaturalist in <b>\", names(locales_list)[locales_list == r$locale], \"<\/b>.<br>In English, it's <em>\")\n      common_genus <- censor_hints(r$target_word, r$tax_info$english_common_name)\n      \n    } else {\n      \n      intro_genus <- paste0(\"There doesn't seem to be a common name for my genus!\")\n      common_genus <- ''\n      attr(common_genus, 'censored') <- FALSE\n\n    }\n    \n    # Construct specific common name hint\n    if('preferred_common_name' %in% names(obstax)) {\n      \n      intro_specific <- paste0(\"My specific common name in <b>\", names(locales_list)[locales_list == r$locale], \"<\/b> is <em>\")\n      common_specific <- censor_hints(r$target_word, obstax$preferred_common_name)\n      \n    } else if('english_common_name' %in% names(obstax)) {\n      \n      intro_specific <- paste0(\"My specific common name isn't available on iNaturalist in <b>\", names(locales_list)[locales_list == r$locale], \"<\/b>.<br>In English, it's <em>\")\n      common_specific <- censor_hints(r$target_word, obstax$english_common_name)\n      \n    } else {\n      \n      intro_specific <- paste0(\"I don't seem to have a specific common name!\")\n      common_specific <- ''\n      attr(common_specific, 'censored') <- FALSE\n      \n    }\n    \n    censorednotice <- \"<br>(Similarities to the target genus itself have been hidden)\"\n    missingnotice <- paste0('<br>Did you know you could <a href=\"https://www.inaturalist.org/taxa/',\n                             if(!'preferred_common_name' %in% names(obstax)) obstax$id else r$tax_info$id, \n                            '\" target=\"_blank\">add<\/a> missing common names to iNaturalist?')\n    \n    eithercensored <- attr(common_genus, 'censored') | attr(common_specific, 'censored')\n    preferredmissing <- (!'preferred_common_name' %in% names(r$tax_info)) | (!'preferred_common_name' %in% names(obstax))\n    \n    # Construct full HTML for common names hint\n    output$common <- renderText(paste0(intro_genus, common_genus, \".<\/em>\"[common_genus!=''], \"<br>\", intro_specific, common_specific, \".<\/em>\"[common_specific!=''], censorednotice[eithercensored], missingnotice[preferredmissing]))\n\n    # Begin the game!\n    r$started <- TRUE\n\n  }\n  \n  reset_game <- function() {\n    r$ready <- FALSE\n    r$pretext <- NULL\n    r$showimage <- FALSE\n    r$showcommon <- FALSE\n    r$all_guesses <- list()\n    r$finished <- FALSE\n    r$started <- FALSE\n  }\n  \n  output$setup_ui <- renderUI({\n    req(!r$started & !r$ready)\n    tagList(\n      h1('iNatle Setup'), \n      hr(),\n      \n      fluidRow(\n       column(6, HTML(\"<b>Enter the language of your common name hint<\/b>\")),\n       column(6, selectInput(\"locale\", NULL, names(locales_list), names(locales_list)[locales_list == isolate(r$locale)], width = '100%'))\n      ),\n      hr(),\n      \n      HTML(\"<p><b>Enter an observation ID number<\/b><br>to accept someone's challenge<\/p>\"),\n      fluidRow(\n        column(7, textInput('obs_id', NULL, value = '', width = '100%')),\n        column(5, actionButton('submit_specific', 'Accept Challenge!', style = 'white-space: nowrap;'))\n      ),\n      hr(),\n      \n      HTML(\"<p><b>Or, generate a random game<\/b><br>iNatle will look for any relevant observations yesterday.<br><br>If there were none,<br>it will look for observations on this day in previous years,<br> then this month in previous years,<br> then all observations from any time.<\/p>\"),\n      textInput('place',         HTML(\"<b>Enter a place name<\/b><br>or leave it blank\"),      value = isolate(r$placename),   width = '100%'),\n      textInput('taxon',         HTML(\"<b>Enter a taxonomic group<\/b><br>or leave it blank\"), value = isolate(r$input_taxon), width = '100%'),\n      textInput('user_login',    HTML(\"<b>Enter a user login name<\/b><br>or leave it blank\"), value = isolate(r$user_login),  width = '100%'),\n      HTML(\"<b>Enter difficulty parameters<\/b>\"),\n      fluidRow(\n        column(6, numericInput('rarity', \"Species rarity\",   value = isolate(r$rarity),  min = 1, step = 1, width = '100%')),\n        column(6, numericInput('maxchar', \"Max word length\", value = isolate(r$maxchar), min = 4, step = 1, width = '100%'))\n      ),\n      actionButton('submit_random', 'Random genus')\n    )\n  })\n  \n  observeEvent(input$submit_specific, {\n    \n    r$placename <- ''\n    r$input_taxon <- ''\n    r$user_login <- ''\n    r$locale <- locales_list[[input$locale]]\n    r$notices <- 'Loading challenge...'\n    r$is_random <- FALSE\n    r$ready <- TRUE\n    \n  })\n  \n  observeEvent(input$submit_random, {\n    \n    r$locale <- locales_list[[input$locale]]\n    r$notices <- 'Loading random genus...'\n    r$is_random <- TRUE\n    r$ready <- TRUE\n    \n  })\n  \n  output$notices_ui <- renderText({\n    req(!r$started)\n    HTML(paste0('<p style=\"margin-top: 10px\">', r$notices, '<\/p>'))\n  })\n  \n  observeEvent(r$ready, {\n    \n    if(r$ready) {\n      \n      if(!r$is_random) {\n        \n        if(input$obs_id != '') {\n        \n          get_specific_obs(input$obs_id)\n          \n          if(anyNA(r$ref_obs)) {\n      \n            r$notices <- 'ID number does not appear to be valid'\n            reset_game()\n            \n          } else {\n            \n            assemble_game()\n            \n          }\n        \n        } else {\n          \n          r$notices <- 'Please enter an ID number'\n          reset_game()\n          \n        }\n        \n      } else {\n        \n        r$placename <- input$place\n        r$input_taxon <- input$taxon\n        r$user_login <- input$user_login\n        r$rarity <- input$rarity\n        r$maxchar <- input$maxchar\n    \n        # iNaturalist ID number for a taxon specified by the user\n        if(r$input_taxon == '') {\n          taxid <-  NULL\n        } else {\n          taxid <- tryCatch({\n            get_tax(r$input_taxon)$id\n          }, error = \\(e) NA)\n        }\n        \n        if(!anyNA(taxid)) {\n          try_place(r$placename, taxid)\n          assemble_game()\n        } else {\n          r$notices <- 'Input taxon is not recognized'\n          reset_game()\n        }\n        \n      }\n      \n    }\n    \n  })\n  \n  output$game_ui <- renderUI({\n    req(r$started)\n    tagList(\n      h3(\"iNatle\"),\n      h4(\"What's my genus?\"),\n      uiOutput(\"pretext\"),\n      uiOutput(\"image_div\"),\n      uiOutput(\"common_div\"),\n      uiOutput(\"previous_guesses\"),\n      uiOutput(\"current_guess\"),\n      uiOutput(\"endgame\"),\n      uiOutput(\"new_game_ui\"),\n      uiOutput(\"keyboard\")\n    )\n  })\n  \n  observeEvent(input$showimage, {\n    r$showimage <- TRUE\n  })\n  \n  observeEvent(input$hideimage, {\n    r$showimage <- FALSE\n  })\n  \n  output$image_div <- renderUI({\n    if(r$showimage) {\n      list(\n        htmlOutput('iurl'),\n        actionButton('hideimage', 'Hide image', style = \"margin: 5px;\")\n      )\n    } else {\n      actionButton('showimage', 'Show image', style = \"margin: 5px;\")\n    }\n  })\n  \n  observeEvent(input$showcommon, {\n    r$showcommon <- TRUE\n  })\n  \n  observeEvent(input$hidecommon, {\n    r$showcommon <- FALSE\n  })\n  \n  output$common_div <- renderUI({\n    if(r$showcommon) {\n      list(\n        htmlOutput('common'),\n        actionButton('hidecommon', 'Hide common name', style = \"margin: 5px;\")\n      )\n    } else {\n      actionButton('showcommon', 'Show common name', style = \"margin: 5px;\")\n    }\n  })\n\n  observeEvent(input$new_game, {\n    r$notices <- ''\n    reset_game()\n  })\n\n  # Rendering UI Elements\n  output$previous_guesses <- renderUI({\n    res <- lapply(r$all_guesses, function(guess) {\n      letters <- guess$letters\n      row <- mapply(letters, guess$matches, SIMPLIFY = FALSE, USE.NAMES = FALSE, FUN = function(letter, match) {\n        match_type <- match\n        div(toupper(letter), class = paste(\"letter\", match_type))\n      })\n      div(class = \"word\", row)\n    })\n\n    scroll_js <- \"document.querySelector('.guesses').scrollTo(0, document.querySelector('.guesses').scrollHeight);\"\n    tagList(res, tags$script(HTML(scroll_js)))\n  })\n\n  output$current_guess <- renderUI({\n    if(!r$started || r$finished) return()\n\n    letters <- r$current_guess_letters\n    target_length <- isolate(nchar(r$target_word))\n\n    if(length(letters) < target_length) {\n      letters[(length(letters) + 1):target_length] <- \"\"\n    }\n\n    div(\n      class = \"word\",\n      lapply(letters, function(letter) {\n        div(toupper(letter), class = \"letter guess\")\n      })\n    )\n  })\n\n  output$new_game_ui <- renderUI({\n    if(r$finished) {\n      actionButton(\"new_game\", \"New Game\")\n    }\n  })\n\n  used_letters <- reactive({\n    letter_matches <- list()\n\n    lapply(r$all_guesses, function(guess) {\n      letters <- guess$letters\n      mapply(letters, guess$matches, SIMPLIFY = FALSE, USE.NAMES = FALSE, FUN = function(letter, match) {\n               prev_match <- letter_matches[[letter]]\n               if(is.null(prev_match) ||\n                  (match == \"correct\" && prev_match != \"correct\") ||\n                  (match == \"in-word\" && prev_match == \"not-in-word\")) {\n                 letter_matches[[letter]] <<- match\n               }\n             }\n      )\n    })\n\n    letter_matches\n  })\n\n  keys <- list(\n    c(\"Q\", \"W\", \"E\", \"R\", \"T\", \"Y\", \"U\", \"I\", \"O\", \"P\"),\n    c(\"A\", \"S\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\"),\n    c(\"Enter\", \"Z\", \"X\", \"C\", \"V\", \"B\", \"N\", \"M\", \"Back\")\n  )\n\n  renderKeyboard <- function(keys, prev_match_type) {\n    lapply(keys, function(row) {\n      row_keys <- lapply(row, function(key) {\n        class <- \"key\"\n        key_lower <- tolower(key)\n        if(!is.null(prev_match_type[[key_lower]])) {\n          class <- c(class, prev_match_type[[key_lower]])\n        }\n        if(key %in% c(\"Enter\", \"Back\")) {\n          class <- c(class, \"wide-key\")\n        }\n        actionButton(key, key, class = class)\n      })\n      div(class = \"keyboard-row\", row_keys)\n    })\n  }\n\n  output$keyboard <- renderUI({\n    prev_match_type <- used_letters()\n    div(class = \"keyboard\", renderKeyboard(keys, prev_match_type))\n  })\n\n  observeKeyPress <- function(key) {\n    observeEvent(input[[key]], {\n      if(!r$started || r$finished) return()\n      cur <- r$current_guess_letters\n      if(length(cur) < isolate(nchar(r$target_word))) {\n        r$current_guess_letters <- c(cur, tolower(key))\n      }\n    })\n  }\n\n  # Add listeners foreach key, except Enter and Back\n  lapply(unlist(keys, recursive = FALSE), function(key) {\n    if(key %in% c(\"Enter\", \"Back\")) return()\n    observeKeyPress(key)\n  })\n\n  observeEvent(input$Back, {\n    if(length(r$current_guess_letters) > 0) {\n      r$current_guess_letters <- r$current_guess_letters[-length(r$current_guess_letters)]\n    }\n  })\n\n  observeEvent(input$Enter, {\n    guess <- paste(r$current_guess_letters, collapse = \"\")\n\n    all_guesses_new <- r$all_guesses\n    check_result <- check_word(guess, r$target_word)\n    all_guesses_new[[length(all_guesses_new) + 1]] <- check_result\n    r$all_guesses <- all_guesses_new\n\n    if(isTRUE(check_result$win)) r$finished <- TRUE\n\n    r$current_guess_letters <- character(0)\n  })\n\n  renderEndgameUI <- function(guesses) {\n    lines <- lapply(guesses, function(guess) {\n      line <- vapply(guess$matches, function(match) {\n        switch(match,\n               \"correct\" = \"🟩\",\n               \"in-word\" = \"🟨\",\n               \"not-in-word\" = \"⬜\"\n        )\n      }, character(1))\n\n      div(paste(line, collapse = \"\"))\n    })\n    div(class = \"endgame-content\", \n      HTML(paste0('iNatle ID: ', r$ref_obs$results[[1]]$id,\n                  if(r$placename != '')   '<br>Place: ' else NULL, r$placename,\n                  if(r$input_taxon != '') '<br>Taxon: ' else NULL, r$input_taxon,\n                  if(r$user_login != '')  '<br>User: ' else NULL,  r$user_login,\n                  '<br>Hint language: ', names(locales_list)[locales_list == r$locale], '<br>')),\n      lines,\n      HTML(paste0('<br>https://thecnidaegritty.org/iNatle/?obs_id=', r$ref_obs$results[[1]]$id))\n    )\n  }\n\n  output$endgame <- renderUI({\n    if(r$finished) {\n      renderEndgameUI(r$all_guesses)\n    }\n  })\n\n}\n\ncheck_word <- function(guess_str, target_str) {\n  \n  target <- strsplit(target_str, \"\")[[1]]\n  guess <- strsplit(guess_str, \"\")[[1]]\n  guess <- c(guess, rep(' ', length(target) - length(guess)))\n\n  result <- rep(\"not-in-word\", length(guess))\n  remaining <- character(0)\n\n  for(i in seq_along(guess)) {\n    if(guess[i] == target[i]) {\n      result[i] <- \"correct\"\n    } else {\n      remaining <- c(remaining, target[i])\n    }\n  }\n\n  for(i in seq_along(guess)) {\n    if(guess[i] != target[i] && guess[i] %in% remaining) {\n      result[i] <- \"in-word\"\n      remaining <- remaining[-match(guess[i], remaining)]\n    }\n  }\n\n  list(\n    word = guess_str,\n    letters = guess,\n    matches = result,\n    win = all(result == \"correct\")\n  )\n\n}\n\nshinyApp(ui, server)\n\n# Use my custom shinylive template to make sure there's jekyll frontmatter on the export\n# Then make simple update to shinylive.js so the url parameters are forwarded to the iframe (sed command specific to macos)\n# shinylive::export('~/scripts/iNatle/', '~/scripts/thecnidaegritty/iNatle/', template_dir = \"~/scripts/thecnidaegritty/scripts/shinylive_jekyll_template\", template_params = list(title = 'iNatle', permalink = '/iNatle/'))\n# system(\"sed -i '' 's/viewerFrameRef.current.src = appInfo.urlPath/viewerFrameRef.current.src = appInfo.urlPath + window.location.search;/g' ~/scripts/thecnidaegritty/iNatle/shinylive/shinylive.js\")\n# httpuv::runStaticServer(\"~/scripts/thecnidaegritty/iNatle/\")\n","type":"text"},{"name":"LICENSE","content":"MIT License\n\nCopyright (c) 2022 Winston Chang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n","type":"text"},{"name":"README.md","content":"# iNatle\n\nA game that lets you guess or ID the genus of organisms observed locally.\n\nCurrent iNatle: [code]() [deployed app](https://thecnidaegritty.org/iNatle)\n","type":"text"},{"name":"www/custom.js","content":"// custom.js\n\nconst letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\nconst all_key_ids = [...letters, 'Enter', 'Back'];\n\ndocument.addEventListener('keydown', function(e) {\n  let key = e.code.replace(/^Key/, '');\n  if (letters.includes(key)) {\n    document.getElementById(key).click();\n  } else if (key === 'Enter') {\n    document.getElementById('Enter').click();\n  } else if (key === 'Backspace') {\n    document.getElementById('Back').click();\n  }\n});\n\ndocument.addEventListener('touchstart', function(e) {\n  if (all_key_ids.includes(e.target.id)) {\n    e.target.click();\n    e.target.style.pointerEvents = 'none';\n    e.preventDefault();\n    in_button_touch = true;\n  }\n});\n\ndocument.addEventListener('touchend', function(e) {\n  all_key_ids.forEach(id => {\n    document.getElementById(id).style.pointerEvents = null;\n  });\n  if (in_button_touch) {\n      if (all_key_ids.includes(e.target.id)) {\n          // Disable text selection and triggering of click event.\n          e.preventDefault();\n      }\n    in_button_touch = false;\n  }\n});\n","type":"text"},{"name":"www/styles.css","content":"/* styles.css */\n\n.container-fluid {\n    text-align: center;\n    vertical-align: top;\n    height: 100%;\n    display: grid;\n    grid-template-rows: 1fr auto;\n    width: fit-content;\n}\n\n.shiny-input-text {\n    text-align: center;\n}\n\n.form-control {\n    text-align: center;\n}\n\n.guesses {\n    height: 100%;\n    width: fit-content;\n}\n\n.guesses .word {\n    margin: 5px;\n    white-space: nowrap;\n    text-align: center;\n}\n.guesses .word > .letter {\n    display: inline-block;\n    width: 50px;\n    height: 50px;\n    text-align: center;\n    vertical-align: middle;\n    border-radius: 3px;\n    line-height: 50px;\n    font-size: 32px;\n    font-weight: bold;\n    user-select: none;\n    color: white;\n    font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;\n}\n.guesses .word > .correct {\n    background-color: #6a5;\n}\n.guesses .word > .in-word {\n    background-color: #db5;\n}\n.guesses .word > .not-in-word {\n    background-color: #888;\n}\n.guesses .word > .guess {\n    color: black;\n    background-color: white;\n    border: 1px solid black;\n}\n.keyboard {\n    height: 100%;\n    margin: 10px;\n    user-select: none;\n}\n.keyboard .keyboard-row {\n    margin: 3px;\n    white-space: nowrap;\n}\n.keyboard .keyboard-row .key {\n    display: inline-block;\n    padding: 0;\n    width: 30px;\n    height: 50px;\n    text-align: center;\n    vertical-align: middle;\n    border-radius: 3px;\n    line-height: 50px;\n    font-size: 18px;\n    font-weight: bold;\n    color: black;\n    font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;\n    background-color: #ddd;\n    touch-action: none;\n}\n.keyboard .keyboard-row .key:focus {\n    outline: none;\n}\n.keyboard .keyboard-row .key.wide-key {\n    font-size: 15px;\n    width: 50px;\n}\n.keyboard .keyboard-row .key.correct {\n    background-color: #6a5;\n    color: white;\n}\n.keyboard .keyboard-row .key.in-word {\n    background-color: #db5;\n    color: white;\n}\n.keyboard .keyboard-row .key.not-in-word {\n    background-color: #888;\n    color: white;\n}\n.endgame-content {\n    font-family: Helvetica, Arial, sans-serif;\n    display: inline-block;\n    line-height: 1.4;\n    letter-spacing: .2em;\n    margin: 20px 8px;\n    width: fit-content;\n    padding: 20px;\n    border-radius: 5px;\n    box-shadow: 4px 4px 19px rgb(0 0 0 / 17%);\n}\n\n","type":"text"}]
